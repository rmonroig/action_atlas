import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';

self.skipWaiting();
clientsClaim();

cleanupOutdatedCaches();

// Precache all assets generated by vite
precacheAndRoute(self.__WB_MANIFEST);

// -------------------------------------------------------------------------
// SHARE TARGET HANDLER (Share Audio from other apps)
// -------------------------------------------------------------------------

self.addEventListener('fetch', (event) => {
    const url = new URL(event.request.url);

    // Intercept POST requests to /whatsapp (defined in manifest share_target)
    if (event.request.method === 'POST' && url.pathname.includes('/whatsapp')) {
        event.respondWith(
            (async () => {
                try {
                    const formData = await event.request.formData();
                    const mediaFile = formData.get('media'); // 'media' matches manifest param name

                    if (mediaFile) {
                        // Open IndexedDB to store the file
                        const db = await openDB();
                        await storeFile(db, mediaFile);
                        console.log('[SW] Shared file stored in IDB');
                    }
                } catch (err) {
                    console.error('[SW] Error parsing shared file:', err);
                }

                // Redirect content to the GET page to show the UI
                return Response.redirect('/whatsapp', 303);
            })()
        );
    }
});

// --- Simple IndexedDB Helper for SW ---
function openDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('share-target-db', 1);

        request.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('shared-files')) {
                db.createObjectStore('shared-files', { keyPath: 'id', autoIncrement: true });
            }
        };

        request.onsuccess = (e) => resolve(e.target.result);
        request.onerror = (e) => reject(e.target.error);
    });
}

function storeFile(db, file) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction('shared-files', 'readwrite');
        const store = tx.objectStore('shared-files');

        // We assume only one file handling at a time for simplicity, 
        // but append just in case. Client clears it.
        const request = store.put({
            file: file,
            created: Date.now()
        });

        request.onsuccess = () => resolve();
        request.onerror = (e) => reject(e.target.error);
    });
}
